### 常问

#### 0.bean的生命周期

1、解析xml配置或注解配置的类，得到BeanDefinition;
2、通过BeanDefinition反射创建Bean对象；
3、对Bean对象进行属性填充；
4、回调实现了Aware接口的方法，如BeanNameAware;
5、调用BeanPostProcessor的初始化前方法；
6、调用init初始化方法；
7、调用BeanPostProcessor的初始化后方法，此处会进行AOP;
8、将创建的Bean对象放入一个Map中；
9、业务使用Bean对象；
10、Spring容器关闭时调用DisposableBean的destory0方法；

#### 1.Java 语言的特点

* **Java 语言是简单的：**

  Java 语言的语法与 C 语言和 C++ 语言很接近，使得大多数程序员很容易学习和使用。另一方面，Java 丢弃了 C++ 中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java 语言不使用指针，而是引用。并提供了自动分配和回收内存空间，使得程序员不必为内存管理而担忧。

* **Java 语言是面向对象的：**

  Java 语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为 implements）。Java 语言全面支持动态绑定，而 C++语言只对虚函数使用动态绑定。总之，Java语言是一个纯的面向对象程序设计语言。

* **Java语言是分布式的：**

  Java 语言支持 Internet 应用的开发，在基本的 Java 应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括 URL、URLConnection、Socket、ServerSocket 等。Java 的 RMI（远程方法激活）机制也是开发分布式应用的重要手段。

* **Java 语言是健壮的**：

  Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证。对指针的丢弃是 Java 的明智选择。Java 的安全检查机制使得 Java 更具健壮性。

* **Java语言是安全的：**

  Java通常被用在网络环境中，为此，Java 提供了一个安全机制以防恶意代码的攻击。除了Java 语言具有的许多安全特性以外，Java 对通过网络下载的类具有一个安全防范机制（类 ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类 SecurityManager）让 Java 应用设置安全哨兵。

* **Java 语言是体系结构中立的：**

  Java 程序（后缀为 java 的文件）在 Java 平台上被编译为体系结构中立的字节码格式（后缀为 class 的文件），然后可以在实现这个 Java 平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。

* **Java 语言是可移植的：**

  这种可移植性来源于体系结构中立性，另外，Java 还严格规定了各个基本数据类型的长度。Java 系统本身也具有很强的可移植性，Java 编译器是用 Java 实现的，Java 的运行环境是用 ANSI C 实现的。

* **Java 语言是解释型的：**

  如前所述，Java 程序在 Java 平台上被编译为字节码格式，然后可以在实现这个 Java 平台的任何系统中运行。在运行时，Java 平台中的 Java 解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。

* **Java 是高性能的：**

  与那些解释型的高级脚本语言相比，Java 的确是高性能的。事实上，Java 的运行速度随着 JIT(Just-In-Time）编译器技术的发展越来越接近于 C++。

* **Java 语言是多线程的：**

  在 Java 语言中，线程是一种特殊的对象，它必须由 Thread 类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为 Thread(Runnable) 的构造子类将一个实现了 Runnable 接口的对象包装成一个线程，其二，从 Thread 类派生出子类并重写 run 方法，使用该子类创建的对象即为线程。值得注意的是 Thread 类已经实现了 Runnable 接口，因此，任何一个线程均有它的 run 方法，而 run 方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java 语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为 synchronized）。

* **Java 语言是动态的：**

  Java 语言的设计目标之一是适应于动态变化的环境。Java 程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，Java 中的类有一个运行时刻的表示，能进行运行时刻的类型检查。

####  2.比较 JVM 和 JDK 以及 JRE

JVM + 核心类库 = JRE

JRE + java开发工具（javac.exe/jar.exe) = JDK

* JDK(Java Development Kit Java开发工具包)，JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。其中的开发工具包括编译工具(javac.exe) 打包工具(jar.exe)等。

* JRE(Java Runtime Environment Java运行环境) 是 JDK 的子集，也就是包括 JRE 所有内容，以及开发应用程序所需的编译器和调试器等工具。JRE 提供了库、Java 虚拟机（JVM）和其他组件，用于运行 Java 编程语言、小程序、应用程序。JVM(Java Virtual Machine Java虚拟机)，
* JVM可以理解为是一个虚拟出来的计算机，具备着计算机的基本运算方式，它主要负责把 Java 程序生成的字节码文件，解释成具体系统平台上的机器指令，让其在各个平台运行。



####  3. Java 语言“解释与编译并存

　　Java 程序从源代码到运行一般有下面 3 步：

​                                ![为什么说Java既是编译型语言又是解释型语言_Java](https://raw.githubusercontent.com/1993884953/PicGo-Photo/master/PigCo/202303181141218.png)

　　1、代码书写完成之后，保存成.Java文件。

　　2、.Java文件运行时，Java不是直接编译或解释成机器码文件的，它会先通过JDK中的javac.exe编译成Java虚拟机(JVM )可理解的字节码文件，此时，Java使用了编译。

　　3、字节码文件之后会被虚拟机JVM逐行解释成机器可执行的二进制机器码，此时，Java使用了解释。

　　4、从.class文件到机器码这一步， JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。

　　当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。

　Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。

####  4.基本类型有哪几种，各占多少位？

只有8种基本类型可以算.其他引用类型都是由java[虚拟机](https://so.csdn.net/so/search?q=虚拟机&spm=1001.2101.3001.7020)决定的自己不能操作

- 表示范围公式：(-2的n-1次方) 至 （2的n-1次方 - 1），
- 因为第一位用于当做符号位，第1个bit表示符号,0表示正数,1表示负数

| 基本类型 | 占的内存（1字节是8位） | 表示范围                                            |
| -------- | ---------------------- | --------------------------------------------------- |
| byte     | 1字节                  | -128至127：-2的7次方至2的7次方-1                    |
| short    | 2字节                  | -32768至32767：-2的15次方至2的15次方-1              |
| int      | 4字节                  | -2147483648 至 2147483647 ：-2的31次方至2的31次方-1 |
| long     | 8字节                  | -2的63次方至2的63次方-1                             |
| float    | 4字节                  | 有效小数位6-7位                                     |
| double   | 8字节                  | 有效小数位15位                                      |
| char     | 2字节                  |                                                     |
| boolean  | 1字节                  |                                                     |



####  5.Java 泛型，类型擦除

所谓泛型，就是指在定义一个类、接口或者方法时可以指定类型参数。这个类型参数我们可以在使用类、接口或者方法时动态指定。

使用泛型可以给我们带来如下的**好处**：

- 编译时类型检查：当我们使用泛型时，加入向容器中存入非特定对象在编译阶段就会报错。假如不使用泛型，可以向容器中存入任意类型，容易出现类型转换异常。
- 不需要进行类型强制转换：使用泛型后容器可以记住存入容器中的对象的类型；
- 代码可读性提升：使用泛型后开发人员看一眼就知道容器中存放的是何种对象。

**泛型擦除**是指Java中的泛型只在编译期有效，在运行期间会被删除。也就是说所有泛型参数在编译后都会被清除掉。

#### 6.== 和 equals() 的区别。

*  == 的作用

>  基本类型：比较的是值是否相等

> 引用类型：比较的是内存地址是否相等

*  equals 的作用

equals 默认是采用 == 来实现，Object 类中 equals 方法源代码如下：

```typescript
public boolean equals(Object obj) {  
    return this == obj;  
}
```

从源码上看 equals 和 == 作用是一样的，那么是不是 == 就可以代替 equals 了呢？
我们再来看看 String 类中 equals 方法源代码：

```java
public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
}
```

可以看到 String 类重写了 Object 类中的 equals 方法，把比较引用类型内存地址是否相等改成了比较值是否相等，还有很多类也重写了该方法，比如Integer等。所以一般来说 equals 方法不管比较基本类型还是引用类型比较的都是值是否相等！

####  7.**hashCode() 和 equals()**

 这个问题经常问，面试官经常问为什么重写 equals() 时要重写 hashCode() 方法？ 

【强制】关于hashCode和equals的处理，避循如下规则：

* 只要重写equals,就必须重写hashCode。

* 因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法。

* 如果自定义对象做为ap的键，那么必须重写hashCode和equals。
  说明：String重写了hashCode和equals方法，所以我们可以非常愉快地使用String对象作为key来使用。

* ```
  1.hashCode()方法存在的主要目的就是提高效率。
  2.在集合中判断两个对象相等的条件，其实无论是往集合中存数据，还是从集合中取数据，包括如果控制唯一性等，都是用这个条件判断的，条件如下：
  首先判断两个对象的hashCode是否相等，如果不相等，就认为这两个对象不相等，就完成了。如果相等，才会判断两个对象的equals()是否相等，如果不相等，就认为这两个对象不相等，如果相等，那就认为这两个对象相等。
  
  作者：曹元_
  链接：https://www.jianshu.com/p/78ded75fe9af
  来源：简书
  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
  ```

####  8.**重载和重写的区别。** 

方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态 性，而后者实现的是运行时的多态性。

* 重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不 同、顺序不同），
  * 与方法返回值和访问修饰符无关，即重载的方法不能根据返回 类型进行区分

* 重写：发生在父子类中，方法名、参数列表必须相同，
  * 返回值小于等于父类，
  * 抛 出的异常小于等于父类，
  * 访问修饰符大于等于父类（里氏代换原则）；
  * 如果父类 方法访问修饰符为private则子类中就不是重写。  


####  9.深拷贝和浅拷贝。

浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，
深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加 的指针指向这个新的内存，

> 使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的 错误。
> 浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来 的对象也会相应的改
> 变。
> 深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。  

####  10.面向对象和面向过程的区别

面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。

面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。

####  11.成员变量与局部变量的区别。

```
从语法形式 存储位置 生存时间  是否赋初值

1.从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰；
2.从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存
3.从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
4.成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。
```

####  12.面向对象三大特性是什么

**面向对象的三个基本特征是：封装、继承、多态**

- 封装

  封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

- 继承

  继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。

  要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。

- 多态性

  多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。

  实现多态，有两种方式，覆盖和重载。覆盖和重载的区别在于，覆盖在运行时决定，重载是在编译时决定。并且覆盖和重载的机制不同，例如在 Java 中，重载方法的签名必须不同于原先方法的，但对于覆盖签名必须相同。

####  13.String、StringBuffer 和 StringBuilder 的区别。

* 区别

String中的对象是不可变的，也就可以理解为常量，线程安全。

> AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。

StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。

StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。

* 性能

每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。

StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。

相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。  

####  14.异常和错误。

![image-20220621155729452](https://raw.githubusercontent.com/1993884953/PicGo-Photo/master/PigCo/202303181141220.png)

* Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。  大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。  
* Exception（异常）:是程序本身可以处理的异常。Exception 类有一个重要的子类  
  * RuntimeException。RuntimeException 异常由 Java 虚拟机抛出。
  * NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）、
  * ArithmeticException（算术运算异常，一个整数除以 0 时，抛出该异常）和
  * ArrayIndexOutOfBoundsException （下标越界异常）

####  15.序列化和反序列化

**一、是什么**

序列化：就是将对象转化成字节序列的过程。

反序列化：就是讲字节序列转化成对象的过程。

对象序列化成的字节序列会包含对象的类型信息、对象的数据等，说白了就是包含了描述这个对象的所有信息，能根据这些信息“复刻”出一个和原来一模一样的对象。

**二、那么为什么要去进行序列化呢**

1. 持久化：对象是存储在JVM中的堆区的，但是如果JVM停止运行了，对象也不存在了。序列化可以将对象转化成字节序列，可以写进硬盘文件中实现持久化。在新开启的JVM中可以读取字节序列进行反序列化成对象。
2. 网络传输：网络直接传输数据，但是无法直接传输对象，可在传输前序列化，传输完成后反序列化成对象。所以所有可在网络上传输的对象都必须是可序列化的。

**三、怎么去实现对象的序列化呢？**

Java为我们提供了对象序列化的机制，规定了要实现序列化对象的类要满足的条件和实现方法。

1. 对于要序列化对象的类要去实现Serializable接口或者Externalizable接口
2. 实现方法：JDK提供的ObjectOutputStream和ObjectInputStream来实现序列化和反序列化

下面分别实现Serializable和Externalizable接口来演示序列化和反序列化

####  16.List、Set、 Map 的区别

##### List(列表)

  `List`的元素以线性方式存储，可以存放重复对象，`List`主要有以下两个实现类：

- `ArrayList` : 长度可变的数组，可以对元素进行随机的访问，向`ArrayList`中插入与删除元素的速度慢。 `JDK8` 中`ArrayList`扩容的实现是通过`grow()`方法里使用语句`newCapacity = oldCapacity + (oldCapacity >> 1)`（即1.5倍扩容）计算容量，然后调用`Arrays.copyof()`方法进行对原数组进行复制。
- `LinkedList`: 采用链表数据结构，插入和删除速度快，但访问速度慢。

##### Set(集合)

  `Set`中的对象不按特定(HashCode)的方式排序，并且没有重复对象，`Set`主要有以下两个实现类：

- `HashSet`： `HashSet`按照哈希算法来存取集合中的对象，存取速度比较快。当`HashSet`中的元素个数超过数组大小*`loadFactor`（默认值为0.75）时，就会进行近似两倍扩容（`newCapacity = (oldCapacity << 1) + 1`）。
- `TreeSet` ：`TreeSet`实现了`SortedSet`接口，能够对集合中的对象进行排序。

##### Map(映射)

  `Map`是一种把键对象和值对象映射的集合，它的每一个元素都包含一个键对象和值对象。 `Map`主要有以下两个实现类：

- `HashMap`：`HashMap`基于散列表实现，其插入和查询`<K,V>`的开销是固定的，可以通过构造器设置容量和负载因子来调整容器的性能。
- `LinkedHashMap`：类似于`HashMap`，但是迭代遍历它时，取得`<K,V>`的顺序是其插入次序，或者是最近最少使用(`LRU`)的次序。
- `TreeMap`：`TreeMap`基于红黑树实现。查看`<K,V>`时，它们会被排序。`TreeMap`是唯一的带有`subMap()`方法的`Map`，`subMap()`可以返回一个子树。

##### HashMap

  底层实现：`HashMap`底层整体结构是一个[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)，数组中的每个元素又是一个链表。每次添加一个对象（put）时会产生一个链表对象（`Object`类型），`Map`中的每个`Entry`就是数组中的一个元素（`Map.Entry`就是一个`<Key,Value>`），它具有由当前元素指向下一个元素的引用，这就构成了链表。
  存储原理：当向`HsahMap`中添加元素的时候，先根据`HashCode`重新计算`Key`的`Hash`值，得到数组下标，如果数组该位置已经存在其他元素，那么这个位置的元素将会以链表的形式存放，新加入的放在链头，最先加入的放在链尾，如果数组该位置元素不存在，那么就直接将该元素放到此数组中的该位置。
  去重原理：不同的`Key`算到数组下标相同的几率很小，新建一个`<K,V>`放入到`HashMap`的时候，首先会计算Key的数组下标，如果数组该位置已经存在其他元素，则比较两个Key，若相同则覆盖写入，若不同则形成链表。
  读取原理：从`HashMap`中读取（get）元素时，首先计算`Key`的`HashCode`，找到数组下标，然后在对应位置的链表中找到需要的元素。
  扩容机制：当`HashMap`中的元素个数超过数组大小*`loadFactor`（默认值为0.75）时，就会进行2倍扩容（`oldThr << 1`）。

##### 三者区别

| 比较       | List                                                      | Set                                                      | Map                                                          |
| ---------- | --------------------------------------------------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| 继承接口   | Collection                                                | Collection                                               |                                                              |
| 常见实现类 | AbstractList(其常用子类有ArrayList、LinkedList、Vector)   | AbstractSet(其常用子类有HashSet、LinkedHashSet、TreeSet) | HashMap、HashTable                                           |
| 常见方法   | add( )、remove( )、clear( )、get( )、contains( )、size( ) | add( )、remove( )、clear( )、contains( )、size( )        | put( )、get( )、remove( )、clear( )、containsKey( )、containsValue( )、keySet( )、values( )、size( ) |
| 元素       | 可重复                                                    | 不可重复(用`equals()`判断)                               | 不可重复                                                     |
| 顺序       | 有序                                                      | 无序(实际上由HashCode决定)                               |                                                              |
| 线程安全   | Vector线程安全                                            |                                                          | Hashtable线程安全                                            |

文章知识点与官方知识档案匹配，可进一步学习相关知识

[Java技能树](https://edu.csdn.net/skill/java/java-f772778d75db409cac92cb1ee312cccb)[集合](https://edu.csdn.net/skill/java/java-f772778d75db409cac92cb1ee312cccb)[Set接口](https://edu.csdn.net/skill/java/java-f772778d75db409cac92cb1ee312cccb)28219 人正在系统学习中

![image-20220621162805218](https://raw.githubusercontent.com/1993884953/PicGo-Photo/master/PigCo/202303181141221.png)



![image-20220602095719883](https://raw.githubusercontent.com/1993884953/PicGo-Photo/master/PigCo/202303181141222.png)



####  17. ArrayList 和 LinkedList 的区别

 答清楚每个分别采用什么数据结构，对比相应的优点和缺点。 

**List：**

1.可以允许重复的对象。 

2.可以插入多个null元素。 

3.是一个有序容器，保持了每个元素的插入顺序，输出的顺序就是插入的顺序。

4.常用的实现类有 ArrayList、LinkedList 和 Vector。ArrayList 最为流行，它提供了使用索引的随意访问，

5.而 LinkedList 则对于经常需要从 List 中添加或删除元素的场合更为合适。

**Set：**

1. 不允许重复对象

2. 无序容器，你无法保证每个元素的存储顺序，TreeSet通过 Comparator 或者Comparable 维护了一个排序顺序。
3. 只允许一个 null 元素
4. 4.Set 接口最流行的几个实现类是 HashSet、LinkedHashSet 以及 TreeSet。最流行的是基于 HashMap 实现的 HashSet；TreeSet 还实现了 SortedSet 接口，

因此 TreeSet 是一个根据其 compare() 和 compareTo() 的定义进行排序的有序容器。

#### 18.HashMap、HashTable、以及 ConcurrentHashMap 的区别。

 现在面试的超高频考点。当面试官问到这个问题的时候，展现你背面试八股文能力的机会来了。 

1. **底层数据结构**： JDK1.7 的 ConcurrentHashMap 底层采用 `分段数组+链表` 实现，而 JDK1.8 的 ConcurrentHashMap 实现跟 HashMap1.8 的数据结构一样，都是 `数组+链表/红黑二叉树`。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似，都是采用 `数组+链表` 的形式。数组是 HashMap 的主体，链表则是为了解决哈希冲突而存在的；
2. **实现线程安全的方式**： ① 在 JDK1.7 的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段( Segment )，每一把锁只锁[容器](https://cloud.tencent.com/product/tke?from=10680)其中的一部分数据，这样多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高了并发访问率。 到了 JDK1.8，摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作，（JDK1.6 以后对 synchronized 锁做了很多的优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable (同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。一个线程访问同步方法时，当其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程就不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈，效率就越低。

**对比图：**

- Hashtable

![img](https://raw.githubusercontent.com/1993884953/PicGo-Photo/master/PigCo/202303181141223.png)

Hashtable

- JDK1.7 的 ConcurrentHashMap

![img](https://raw.githubusercontent.com/1993884953/PicGo-Photo/master/PigCo/202303181141224.png)

JDK1.7 的 ConcurrentHashMap

- JDK1.8 的 ConcurrentHashMap（TreeBin: 红黑二叉树节点；Node: 链表节点）

![img](https://raw.githubusercontent.com/1993884953/PicGo-Photo/master/PigCo/202303181141225.png)

JDK1.8 的 ConcurrentHashMap

####  19.进程和线程的区别。

 这是一个超高频考点，面试回答时别一句一个进程包含很多线程就没了。 

 要答清楚什么是线程什么是进程，线程和进程各自的运行状态、线程的通信方式和进程的通信方式。 

```
java进程和线程区别与不同。

一、定义

1.进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。

2.线程是进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，一个线程可以创建和撤销另一个线程；

进程和线程的关系：

(1)一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。

(2)资源分配给进程，同一进程的所有线程共享该进程的所有资源。

(3)线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

(4)处理机分给线程，即真正在处理机上运行的是线程。

(5)线程是指进程内的一个执行单元，也是进程内的可调度实体。

```

```
线程与进程的区别：

(1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。

(2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。

(3)拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。

(4)系统开销：在创建或撤销进程的时候，由于系统都要为之分配和回收资源，导致系统的明显大于创建或撤销线程时的开销。但进程有独立的地址空间，进程崩溃后，在保护模式下不会对其他的进程产生影响，而线程只是一个进程中的不同的执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但是在进程切换时，耗费的资源较大，效率要差些。

线程的划分尺度小于进程，使得多线程程序的并发性高。

另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大的提高了程序运行效率。

线程在执行过程中，每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，有应用程序提供多个线程执行控制。

从逻辑角度看，多线程的意义子啊与一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
```

####  20.创建线程的方式。

[网站](https://blog.csdn.net/weixin_42950079/article/details/124862582)

 不仅要把创建线程的方式记熟、记住各种方式的优缺点，还要能写出代码来。有的面试官是会让你写代码创建两个线程然后执行一些操作的，比如两个线程交替输出数字。 

####  21.什么是死锁，死锁如何产生，死锁如何避免。

[死锁](https://blog.csdn.net/LCW0102/article/details/124267990)

 超高频问题，几乎大厂的一面和二面都会问到。 

####  22.synchronized 锁升级流程。

[锁升级](https://blog.csdn.net/qq_47425241/article/details/124617767)

 这又是面试八股文的一大考点，锁升级流程记清楚。 

####  23.volatile 关键字。

 对比和 synchronized 的区别。 

[volatile](https://blog.csdn.net/suchahaerkang/article/details/80456085)

####  24.乐观锁和悲观锁的区别。

[乐观锁](https://baijiahao.baidu.com/s?id=1730331465639596673&wfr=spider&for=pc)

####  25.ThreadLocal

[ThreadLocal](https://blog.csdn.net/qq_36098514/article/details/115523892)

 这也是面试八股文的一个高频考点。我面试到后面不想背这里了，面试过程中就尽可能躲着这个知识点，不提到和这相关的，竟然真的苟过去了。 

####  26.线程池

 超高频考点。需要答出线程池有哪几种，各种线程池的优缺点，线程池的重要参数、线程池的执行流程、线程池的饱和策略、如何设置线程池的大小等等。这里也能背十几分钟。 

####  27.ReentrantLock 和 AQS。

 其实我在面试的时候对这里不是很熟，我面试的时候尽量不提到这里，也苟过去了。大家如果时间充足的话还是把这块好好理解一下。如果这里理解透彻了，也能在这里和面试官聊很久。

### 简历面试

自我介绍

我叫**,我之前在java方面有过一年多的后端开发经验,有spring boot +mybatis +mysql等

### 用到技术

#### 主从

1.实现服务器负载均衡

​    即可以通过在主服务器和从服务器之间切分处理客户查询的负荷，从而得到更好的客户相应时间。通常情况下，数据库管理员会有两种思路。

​    一是在主服务器上只实现数据的更新操作。包括数据记录的更新、删除、新建等等作业。而不关心数据的查询作业。数据库管理员将数据的查询请求全部 转发到从服务器中。这在某些应用中会比较有用。如某些应用，像基金净值预测的网站。其数据的更新都是有管理员更新的，即更新的用户比较少。而查询的用户数 量会非常的多。此时就可以设置一台主服务器，专门用来数据的更新。同时设置多台从服务器，用来负责用户信息的查询

​    二是在主服务器上与从服务器切分查询的作业。在这种思路下，主服务器不单单要完成数据的更新、删除、插入等作业，同时也需要负担一部分查询作业。而从服务器的话，只负责数据的查询。当主服务器比较忙时，部分查询请求会自动发送到从服务器重，以降低主服务器的工作负荷。



2.通过复制实现数据的异地备份

​    可以定期的将数据从主服务器上复制到从服务器上，这无疑是先了数据的异地备份。在传统的备份体制下，是将数据备份在本地。此时备份 作业与数据库服务器运行在同一台设备上，当备份作业运行时就会影响到服务器的正常运行。有时候会明显的降低服务器的性能。同时，将备份数据存放在本地，也 不是很安全。如硬盘因为电压等原因被损坏或者服务器被失窃，此时由于备份文件仍然存放在硬盘上，数据库管理员无法使用备份文件来恢复数据。这显然会给企业 带来比较大的损失。

3.提高数据库系统的可用性

​    数据库复制功能实现了主服务器与从服务器之间数据的同步，增加了数据库系统的可用性。当主服务器出现问题时，数据库管理员可以马上让从服务器作为主服务器，用来数据的更新与查询服务。然后回过头来再仔细的检查主服务器的问题。此时一般数据库管理员也会采用两种手段。

​    一是主服务器故障之后，虽然从服务器取代了主服务器的位置，但是对于主服务器可以采取的操作仍然做了一些限制。如仍然只能够进行数据的查询，而 不能够进行数据的更新、删除等操作。这主要是从数据的安全性考虑。如现在一些银行系统的升级，在升级的过程中，只能够查询余额而不能够取钱。这是同样的道 理。

​    二是从服务器真正变成了主服务器。当从服务器切换为主服务器之后，其地位完全与原先的主服务器相同。此时可以实现对数据的查询、更新、删除等操 作。为此就需要做好数据的安全性工作。即数据的安全策略，要与原先的主服务器完全相同。否则的话，就可能会留下一定的安全隐患。

#### mysql Json

[mysql Json](https://b23.tv/BV1WP4y1K7xB)

JSON类型的另一个好处是无须预定义字段，字段可以无限扩展
而传统关系型数据库的列都需预先定义
想要扩展需要执行ALTER TABLE..ADD COLUMN..比较重的操作

![image-20220622135204261](https://raw.githubusercontent.com/1993884953/PicGo-Photo/master/PigCo/202303181141226.png)

```sql
# 使用$.代表是 json数据
SELECT extra->'$.dist request id'from document
```

![image-20220622135919195](https://raw.githubusercontent.com/1993884953/PicGo-Photo/master/PigCo/202303181141227.png)

```
#会进行全表扫描 需要设置虚拟列
```

![image-20220622140535578](https://raw.githubusercontent.com/1993884953/PicGo-Photo/master/PigCo/202303181141228.png)

![image-20220622141115656](https://raw.githubusercontent.com/1993884953/PicGo-Photo/master/PigCo/202303181141229.png)

![image-20220622141216463](https://raw.githubusercontent.com/1993884953/PicGo-Photo/master/PigCo/202303181141230.png)

![image-20220622141258084](https://raw.githubusercontent.com/1993884953/PicGo-Photo/master/PigCo/202303181141231.png)

## 面试问题：

1. 支付开发流程是怎样？
   	1. 我所采用的是对接第三方支付服务器，并没有微信官方一样的流程，但是有额外的返利。首先是对第三方服务器发起支付请求，通过url encode编码，计算sign签名，然后拼接文档上需要的字段，返回给前端，用户跳转到这个url地址。然后用户就可以进行付款了。用户支付完之后第三方服务器会回调之前设置好的回调地址，通过HttpServletRequest获取用户支付结果，对应进行订单的处理和库存的释放或减扣。最后还做了一个支付结果的查询。

2. 当用户发起支付之后，在你还没有收到回调信息的时候，你怎么保证订单支付状态的一致性？
   1. 我会用一个Jobs，去定时的每过一分钟检查订单表里，状态为正在交易进行中，而支付状态为未支付的记录，通过校验这条记录的创建时间是否超过三十分钟，如果超过了这个jobs任务就会将这条记录更改为交易结束状态，从而关闭这个订单。
3. 你们系统的提量是多少？
   1. 从组长给到的信息是，日成交量在7000左右
4. 你使用了nginx配置文件，请问你会部署nginx吗？
   1. 我会部署，当时社区交流系统只是用里一台服务器，后续通过nginx代理是增加到了三台服务器
5. nginx主要是用来做什么的?
   1. 我们对外开放一个80端口,外界就只需要请求这个端口,而这个请求同nginx的反向代理会分配给上有服务器,从而达到负载均衡.
6. 那你怎么去保证`什么什么没听清`规划的共享问题;举个例子,现在有一个用户,我通过nginx推发一台A服务器上,然后进行操作,比如说我有一个订单号放在了session里面,此时我切换了网络环境,我的IP地址换了,然后通过你nginx再次请求的话,它推发到另一台服务器上了,但我之前存在session里面的订单号还拿的吗
   1. 这个问题目前没想到好的思路,(被问蒙了,不知道是啥意思)
7. 你的订单编号的生成规则是怎样的?如何保证线程安全?
   1. 我才用的是国内的一个开放工具包hutool,用里面的雪花Id生成订单id,关于如果保证线程安全,这个我之前没有考虑到,现在我思考了一个,我给出的解决方案是,在mysql层面,我会利用唯一索引,将订单id和userId,保证同一个订单号和同一个userId只会出现一条记录.
8. 你做过微信分享吗
   1. 您是说下单之后跳转到微信程序是吗? 我没有做过,这个不是我的任务
9. 我看有一个微信公众号排号,比如说我觉得你们家很好吃,想分享给朋友,这样的功能是没有的是吗
   1. 是的,当时是给我一个测试的公众号,这个公众号是不可见的,不会出现在你关注的公众号列表里面,所以当时就没有做这个功能,我当时是用请求微信平台的接口,拿到一个限时的二维码url,然后发给前端,打印在排号小票上面,用户扫码才能关注公众号,如果说你要分享这个公众号,我当时是没有做的


10. 你期望薪资是多少?
    1. 15K
11. 你还有什么问题吗?
    1. 简单说一下贵公司的一个情况
12. 中科软科技股,主要操作是保险金的业务.我们现在是有三个系统;一个是新商城(SpringMVC,SSH),Springcloud系统(做保单的,{kafuka}),后台管理系统(SpringMVC,SSH) ,团队10个人.

#### **自我介绍**

面试官你好,我叫程伟,现住宝山区,2021年毕业于信阳职业技术学院,大一大二自学编程,大三上半年去了我哥的公司实习,下半年我入职了南京创卓有限公司进行实习,目前有1年半Java开发经验,

工作中

我使用springboot和mybatis,mysql,lombok 进行后端api开发,

使用caffeine,redis,rabbitmq等中间件,

使用react,ant-desgin编写前端页面,

使用mvn,linux基础命令进行前后端项目打包,部署

使用postman测试接口,swagger配置api文档



我们项目组一般有4个后端,工作中我们先拿到项目,然后开需求评审会,确定需求,设计mysql数据库表的结构,再分配每个人的任务

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

我最近的项目是餐厅点餐收银项目，主要包括 pc 端和 app 端，可以与入驻多家商户

pc 端包括

1.管理员部分,餐桌区域管理，桌台管理，菜品分类，价格计划，菜品加功方案，支付。

2.会员部分包括会员卡类，会员开卡，会员，会员订单。

3.订单部分包括订单管理，账单管理，消费。4 角色管理。5 支付管理。6.优惠券。

App 端包括用户下单以及发货配送。

本人主要负责管理员角色模块,次要负责后厨展示,对接第三方支付等



管理员角色模块,我们是利用aop,自定义了一个权限验证注解,可以根据用户id,查询该id是否具有所需要的角色和权限,一个角色可以有多个权限,一个用户可以有多种角色,如果用户不具备功能所需要的权限,会抛出自定义的异常错误



管理员角色

>  这个项目里划分了很多不同的角色,店家,服务员,会员等,
>
> 店家的账号可以给自己的店铺添加多种角色,如服务员,收银员,每个角色可以设置多个权限,一个用户可以有多个角色
>
> 使用自定义权限注解,从权限列表查询是否该账号是否有对应的角色,角色是否有对应的权限,如果该账号没有对应的角色访问api,会抛出角色权限不足的异常

对接第三方支付

> 1. 支付开发流程是怎样？
>     	1. 我所采用的是对接第三方支付服务器，并没有微信官方一样的流程，但是有额外的返利。首先是对第三方服务器发起支付请求，通过url encode编码，计算sign签名，然后拼接文档上需要的字段，返回给前端，用户跳转到这个url地址。然后用户就可以进行付款了。用户支付完之后第三方服务器会回调之前设置好的回调地址，通过HttpServletRequest获取用户支付结果，对应进行订单的处理和库存的释放或减扣。最后还做了一个支付结果的查询。
> 2. 当用户发起支付之后，在你还没有收到回调信息的时候，你怎么保证订单支付状态的一致性？
>    1. 我会用一个Jobs，去定时的每过一分钟检查订单表里，状态为正在交易进行中，而支付状态为未支付的记录，通过校验这条记录的创建时间是否超过三十分钟，如果超过了这个jobs任务就会将这条记录更改为交易结束状态，从而关闭这个订单。

后厨展示(后加的功能)

> 有一张后厨菜品展示表,判断是否需要后厨去做,像米饭,酒水是不用后厨去做的,然后去把每个消费详情取出,

-----------------------------------------------------

商城系统实现的功能非常之多，包括后台管理、前台系统、订单系统、登录系统、购物车系统、支付系统等系统采用分布式的架构设计其中前台系统和登录系统采用了集群的方式部署后台管理系统中采用了 Maven 的多模块化的管理，其中采用了水平切分的方式 mvc 分层开发，提高了重用性  

分类模块，订单模块，用户登录模块  

> 分类模块
>
> 使用mybaits的动态sql增加查询条件

订单模块

> 我才用的是国内的一个开放工具包hutool,用里面的雪花Id生成订单id,关于如果保证线程安全,这个我之前没有考虑到,现在我思考了一个,我给出的解决方案是,在mysql层面,我会利用唯一索引,将订单id和userId,保证同一个订单号和同一个userId只会出现一条记录.

用户登录



__________

论坛分享项目是一个前后端分离的项目,



前端使用 react 和 ant-design 组件,后端使用 springboot mybaits对系统内用户提供了注册、登录、修改头像、昵称、密码,绑定邮箱功能。可以使已注册用户进行发表帖子、点赞、收藏、评论、内容管理、查看周榜月榜排行等, 

 redis缓存了周榜月榜等热门数据

后面加入了rabbitmq

```
arraylist初始容量为10,1.5倍,-------arraycope

hashmap负载因子为0.75, 扩容是2的倍数--------HashMap计算添加元素的位置时，使用的位运算，这是特别高效的运算；另外，HashMap的初始容量是2的n次幂，扩容也是2倍的形式进行扩容，是因为容量是2的n次幂，可以使得添加的元素均匀分布在HashMap中的数组上，减少hash碰撞，避免形成链表的结构，使得查询效率降低

1.7使用头插法,多线程扩容可能会导致循环链表,[循环链表](https://cloud.tencent.com/developer/article/1498035?from=15425)
```

　cat -n filename |grep "关键字"

　　　　其他情况：

　　　　cat app.log | grep -C 5 '关键字' 　　(显示日志里匹配字串那行以及前后5行)

　　　　cat app.log | grep -B 5 '关键字' 　　(显示匹配字串及前5行)

　　　　cat app.log | grep -A 5 '关键字' 　　(显示匹配字串及后5行)

lsof -i:6379
